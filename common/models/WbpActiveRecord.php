<?php

namespace common\models;

use wbp\file\File;
use wbp\images\models\Image;
use wbp\video\Video;
use Yii;
use yii\behaviors\TimestampBehavior;
use yii\db\Expression;
use yii\helpers\ArrayHelper;

class WbpActiveRecord extends \yii\db\ActiveRecord
{
    const STATUS_DISABLED = 0;
    const STATUS_ACTIVE = 1;

    const ADMIN_ADD_SCENARIO = 'admin-add';
    const ADMIN_EDIT_SCENARIO = 'admin-update';


    protected $arrayPars = [];
    public static $imageTypes = [];
    public static $videoTypes = [];
    public static $fileTypes = [];

    public static $seoKey = '';


    public function behaviors()
    {
        $behaviours = parent::behaviors();
        $additional = [
            'image' => [
                'class' => \wbp\images\behaviors\ImageBehave::className(),
            ],
            'video' => [
                'class' => \wbp\video\behaviors\VideoBehave::className(),
            ],
            'file' => [
                'class' => \wbp\file\behaviors\FileBehave::className(),
            ]
        ];

        if (in_array('created_at', $this->attributes()) && in_array('updated_at', $this->attributes())) {
            $additional = ArrayHelper::merge($additional, [
                'time' => [
                    'class' => TimestampBehavior::className(),
                    'value' => new Expression('NOW()'),
                ]
            ]);
        }

        return ArrayHelper::merge($behaviours, $additional);
    }

    public function beforeSave($insert)
    {
        $attributes = $this->attributes();
        if (in_array('href', $attributes) && in_array('title', $attributes) && $this->href == '') {
            $this->href = $this->urlstr($this->title);
            if (self::find()->where(['href' => $this->href])->all()) $this->href .= '-' . $this->id;
        }

        foreach ($this->arrayPars as $par) {
                if(is_array($this->{$par})){
                    $this->{$par} = array_diff($this->{$par}, array('', NULL, false));
                }


            if (!$this->{$par} || !is_array($this->{$par}) || count($this->{$par}) == 0) {
                $this->{$par} = '';
            } else {
                $this->{$par} =  implode('|', $this->{$par}) ;
            }
        }

        return parent::beforeSave($insert);
    }

    public function afterSave($insert, $changedAttributes)
    {
        $this->saveUploadedImages();
        $this->saveUploadedVideos();
        $this->saveUploadedFiles();
        $this->afterFind();
        return parent::afterSave($insert, $changedAttributes); // TODO: Change the autogenerated stub
    }

    public function afterFind()
    {
        foreach ($this->arrayPars as $par) {

            $this->{$par} = explode('|', $this->{$par});

            foreach ($this->{$par} as $num => $id) {
                $obj=$this->{$par};
                if (!$id) unset($obj[$num]);
            }

        }
        return parent::afterFind();
    }

    public function getMultiLang($name)
    {
        $langPrefix = Yii::$app->lang->getLanguagePrefix();
        return $this->{$name . $langPrefix};
    }

    public function getShortParam($param, $multilang = true, $seperator = '%main-content%')
    {
        if ($multilang) return $this->StripUnclosedTags(explode($seperator, $this->getMultiLang($param))[0]);
        else return $this->StripUnclosedTags(explode($seperator, $this->{$param})[0]);
    }

    public function getFullParam($param, $multilang = true, $seperator = '%main-content%')
    {
        if ($multilang) return $this->StripUnclosedTags(str_replace($seperator, '', $this->getMultiLang($param)));
        else return $this->StripUnclosedTags(str_replace($seperator, '', $this->{$param}));
    }

    public static function getList($key = 'id', $value = 'title', $sort = 'sort,id desc', $where = false)
    {
        $class = get_called_class();
        $result = [];
        $items = $class::find();
        if ($where) $items = $items->where($where);
        $items = $items->orderBy($sort)->asArray()->all();
        foreach ($items as $item) {
            $result[$item[$key]] = $item[$value];//.'&nbsp;';
            //$result[$item[$key]]=mb_strtolower($item[$value]);//.'&nbsp;';
        }
        return $result;
    }

    static function sort($elements, $pars = [])
    {
        $class = get_called_class();
        $items = $class::find()->orderBy('sort, id desc');
        $i = 0;
        foreach ($items->each() as $item) {
            $item->sort = $i;
            $item->save();
            $i++;
        }

        $sort = $class::find()->min('sort');
        foreach ($elements as $element) {
            if (!(int)$element) continue;
            $item = $class::findOne(['id' => $element]);
            if (!$item) continue;
            $item->sort = $sort;
            $item->save();
            $sort++;
        }

    }


    public function saveUploadedImages($item_id = '', $limit = false)
    {
        // Save uploaded images
        if (!$item_id) $item_id = $this->id;
        $types = [];
        $imagesUniques = Yii::$app->request->post('image');
        if (is_array($imagesUniques)) {
            foreach ($imagesUniques as $unique_id) {
                $images = Image::find()->where(['unique_id' => $unique_id]);
                foreach ($images->each() as $img) {
                    $name = $this::className();
                    if (!in_array($img->type, $name::$imageTypes)) continue;
                    if (!in_array($img->type, $types)) $types[] = $img->type;
                    $img->item_id = $item_id;
                    $img->save();
                }
            }
        }
        if ($limit) {
            foreach ($types as $type) {
                $images = Image::find()->where(['item_id' => $item_id, 'type' => $type])->orderBy('sort, id desc');
                $currentLimit = 0;
                foreach ($images->each() as $image) {
                    if ($currentLimit >= $limit) $image->delete();
                    $currentLimit++;
                }
            }
        }

    }

    public function saveUploadedVideos($item_id = '', $limit = false)
    {
        // Save uploaded images
        if (!$item_id) $item_id = $this->id;
        $types = [];
        $videosUniques = Yii::$app->request->post('video');
        if (is_array($videosUniques)) {
            foreach ($videosUniques as $unique_id) {
                $videos = Video::find()->where(['unique_id' => $unique_id]);
                foreach ($videos->each() as $vid) {
                    $name = $this::className();
                    if (!in_array($vid->type, $name::$videoTypes)) continue;
                    if (!in_array($vid->type, $types)) $types[] = $vid->type;
                    $vid->item_id = $item_id;
                    $vid->save();
                }
            }
        }
        if ($limit) {
            foreach ($types as $type) {
                $videos = Video::find()->where(['item_id' => $item_id, 'type' => $type])->orderBy('sort, id desc');
                $currentLimit = 0;
                foreach ($videos->each() as $video) {
                    if ($currentLimit >= $limit) $video->delete();
                    $currentLimit++;
                }
            }
        }

    }

    public function saveUploadedFiles($item_id = '', $limit = false)
    {
        // Save uploaded images
        if (!$item_id) $item_id = $this->id;
        $types = [];
        $filesUniques = Yii::$app->request->post('file');
        if (is_array($filesUniques)) {
            foreach ($filesUniques as $unique_id) {
                $videos = File::find()->where(['unique_id' => $unique_id]);
                foreach ($videos->each() as $vid) {
                    $name = $this::className();
                    if (!in_array($vid->type, $name::$fileTypes)) continue;
                    if (!in_array($vid->type, $types)) $types[] = $vid->type;
                    $vid->item_id = $item_id;
                    $vid->save();
                }
            }
        }
        if ($limit) {
            foreach ($types as $type) {
                $videos = File::find()->where(['item_id' => $item_id, 'type' => $type])->orderBy('sort, id desc');
                $currentLimit = 0;
                foreach ($videos->each() as $video) {
                    if ($currentLimit >= $limit) $video->delete();
                    $currentLimit++;
                }
            }
        }

    }


    public function urlstr($str, $char = '-')
    {
        // Returns $str, in which all non-alphanumeric characters are replaced by $char, and $char is trimmed from both ends.
        return mb_strtolower(trim(preg_replace('/[^[:alnum:]]+/', $char, $this->translitIt($str)), $char));
    }

    public function translitIt($str)
    {
        $tr = array(
            "А" => "A", "Б" => "B", "В" => "V", "Г" => "G",
            "Д" => "D", "Е" => "E", "Ж" => "J", "З" => "Z", "И" => "I",
            "Й" => "Y", "К" => "K", "Л" => "L", "М" => "M", "Н" => "N",
            "О" => "O", "П" => "P", "Р" => "R", "С" => "S", "Т" => "T",
            "У" => "U", "Ф" => "F", "Х" => "H", "Ц" => "TS", "Ч" => "CH",
            "Ш" => "SH", "Щ" => "SCH", "Ъ" => "", "Ы" => "YI", "Ь" => "",
            "Э" => "E", "Ю" => "YU", "Я" => "YA", "а" => "a", "б" => "b",
            "в" => "v", "г" => "g", "д" => "d", "е" => "e", "ж" => "j",
            "з" => "z", "и" => "i", "й" => "y", "к" => "k", "л" => "l",
            "м" => "m", "н" => "n", "о" => "o", "п" => "p", "р" => "r",
            "с" => "s", "т" => "t", "у" => "u", "ф" => "f", "х" => "h",
            "ц" => "ts", "ч" => "ch", "ш" => "sh", "щ" => "sch", "ъ" => "y",
            "ы" => "yi", "ь" => "", "э" => "e", "ю" => "yu", "я" => "ya",

            'ù' => 'u', 'û' => 'u', 'ü' => 'u', 'ÿ' => 'y', 'à' => 'a',
            'â' => 'a', 'æ' => 'ae', 'ç' => 'c', 'é' => 'e', 'è' => 'e',
            'ê' => 'e', 'ë' => 'e', 'ï' => 'i', 'î' => 'i', 'ô' => 'o', 'œ' => 'ce',
            'Ù' => 'U', 'Û' => 'U', 'Ü' => 'U', 'Ÿ' => 'Y', 'À' => 'A', 'Â' => 'A',
            'Æ' => 'AE', 'Ç' => 'C', 'É' => 'E', 'È' => 'E', 'Ê' => 'E', 'Ë' => 'E',
            'Ï' => 'I', 'Î' => 'I', 'Ô' => 'O', 'Œ' => 'CE',

        );
        return strtr($str, $tr);
    }

    function StripUnclosedTags($input)
    {
        // Close <br> tags
        $buffer = str_replace("<br>", "<br/>", $input);
        // Find all matching open/close HTML tags (using recursion)
        $pattern = "/<([\w]+)([^>]*?) (([\s]*\/>)| (>((([^<]*?|<\!\-\-.*?\-\->)| (?R))*)<\/\\1[\s]*>))/ixsm";
        preg_match_all($pattern, $buffer, $matches, PREG_OFFSET_CAPTURE);
        // Mask matching open/close tag sequences in the buffer
        foreach ($matches[0] as $match) {
            $ofs = $match[1];
            for ($i = 0; $i < strlen($match[0]); $i++, $ofs++)
                $buffer[$ofs] = "#";
        }
        // Remove unclosed tags
        $buffer = preg_replace("/<.*$/", "", $buffer);
        // Put back content of matching open/close tag sequences to the buffer
        foreach ($matches[0] as $match) {
            $ofs = $match[1];
            for ($i = 0; $i < strlen($match[0]) && $ofs < strlen($buffer); $i++, $ofs++)
                $buffer[$ofs] = $match[0][$i];
        }
        return $buffer;
    }
}